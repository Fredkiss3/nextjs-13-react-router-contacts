diff --git a/lib-cjs/http/stream.js b/lib-cjs/http/stream.js
index e2aa9c8df433fc04278a1b5ca7201799ab3012be..e13bb303ace151fc847b058db282dddf67a3a09a 100644
--- a/lib-cjs/http/stream.js
+++ b/lib-cjs/http/stream.js
@@ -44,7 +44,10 @@ class HttpStream extends stream_js_1.Stream {
             "type": "store_sql",
             "sql_id": sqlId,
             "sql": sql,
-        }).then(() => undefined, (error) => this.#setClosed(error));
+        }).then(
+            () => undefined,
+            (error) => this.#setClosed(error)
+        );
         return new sql_js_1.Sql(this, sqlState);
     }
     /** @private */
@@ -56,7 +59,10 @@ class HttpStream extends stream_js_1.Stream {
         this.#sendStreamRequest({
             "type": "close_sql",
             "sql_id": sqlState.sqlId,
-        }).then(() => this.#sqlIdAlloc.free(sqlState.sqlId), (error) => this.#setClosed(error));
+        }).then(
+            () => this.#sqlIdAlloc.free(sqlState.sqlId),
+            (error) => this.#setClosed(error)
+        );
     }
     /** @private */
     _execute(stmt) {
@@ -98,11 +104,15 @@ class HttpStream extends stream_js_1.Stream {
     }
     /** Close the stream. */
     close() {
-        this.#setClosed(new errors_js_1.ClientError("Stream was manually closed"));
+        this.#setClosed(
+            new errors_js_1.ClientError("Stream was manually closed")
+        );
     }
     /** @private */
     _closeFromClient() {
-        this.#setClosed(new errors_js_1.ClosedError("Client was closed", undefined));
+        this.#setClosed(
+            new errors_js_1.ClosedError("Client was closed", undefined)
+        );
     }
     /** True if the stream is closed. */
     get closed() {
@@ -114,18 +124,24 @@ class HttpStream extends stream_js_1.Stream {
         }
         this.#closed = error;
         this.#client._streamClosed(this);
-        if (this.#baton !== null || this.#pipeline.length !== 0 || this.#pipelineInProgress) {
+        if (
+            this.#baton !== null ||
+            this.#pipeline.length !== 0 ||
+            this.#pipelineInProgress
+        ) {
             this.#pipeline.push({
                 request: { "type": "close" },
-                responseCallback() { },
-                errorCallback() { },
+                responseCallback() {},
+                errorCallback() {},
             });
             this.#flushPipeline();
         }
     }
     #sendStreamRequest(request) {
         if (this.#closed !== undefined) {
-            return Promise.reject(new errors_js_1.ClosedError("Stream is closed", this.#closed));
+            return Promise.reject(
+                new errors_js_1.ClosedError("Stream is closed", this.#closed)
+            );
         }
         return new Promise((responseCallback, errorCallback) => {
             this.#pipeline.push({ request, responseCallback, errorCallback });
@@ -141,27 +157,31 @@ class HttpStream extends stream_js_1.Stream {
         const promise = (0, isomorphic_fetch_1.fetch)(request);
         this.#pipelineInProgress = true;
         this.#pipeline.length = 0;
-        promise.then((resp) => {
-            if (!resp.ok) {
-                return errorFromResponse(resp).then((error) => {
-                    throw error;
-                });
-            }
-            return resp.json();
-        }).then((respJson) => {
-            const respBody = respJson;
-            this.#baton = respBody["baton"] ?? null;
-            this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
-            handlePipelineResponse(pipeline, respBody);
-        }).catch((error) => {
-            this.#setClosed(error);
-            for (const entry of pipeline) {
-                entry.errorCallback(error);
-            }
-        }).finally(() => {
-            this.#pipelineInProgress = false;
-            this.#flushPipeline();
-        });
+        promise
+            .then((resp) => {
+                if (!resp.ok) {
+                    return errorFromResponse(resp).then((error) => {
+                        throw error;
+                    });
+                }
+                return resp.json();
+            })
+            .then((respJson) => {
+                const respBody = respJson;
+                this.#baton = respBody["baton"] ?? null;
+                this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
+                handlePipelineResponse(pipeline, respBody);
+            })
+            .catch((error) => {
+                this.#setClosed(error);
+                for (const entry of pipeline) {
+                    entry.errorCallback(error);
+                }
+            })
+            .finally(() => {
+                this.#pipelineInProgress = false;
+                this.#flushPipeline();
+            });
     }
     #createPipelineRequest(pipeline) {
         const url = new URL("v2/pipeline", this.#baseUrl);
@@ -173,32 +193,45 @@ class HttpStream extends stream_js_1.Stream {
         if (this.#jwt !== null) {
             headers.set("authorization", `Bearer ${this.#jwt}`);
         }
+
+        console.log("[PATCHED @libsql/client CJS] executing SQL statements", {
+            "requests": pipeline.map((entry) => entry.request),
+            "url": url.toString(),
+        });
         return new isomorphic_fetch_1.Request(url, {
             method: "POST",
             headers,
             body: JSON.stringify(requestBody),
+            // do not cache in next.js
+            cache: "no-store",
         });
     }
 }
 exports.HttpStream = HttpStream;
 function handlePipelineResponse(pipeline, respBody) {
     if (respBody["results"].length !== pipeline.length) {
-        throw new errors_js_1.ProtoError("Server returned unexpected number of pipeline results");
+        throw new errors_js_1.ProtoError(
+            "Server returned unexpected number of pipeline results"
+        );
     }
     for (let i = 0; i < pipeline.length; ++i) {
         const result = respBody["results"][i];
         const entry = pipeline[i];
         if (result["type"] === "ok") {
             if (result["response"]["type"] !== entry.request["type"]) {
-                throw new errors_js_1.ProtoError("Received unexpected type of response");
+                throw new errors_js_1.ProtoError(
+                    "Received unexpected type of response"
+                );
             }
             entry.responseCallback(result["response"]);
-        }
-        else if (result["type"] === "error") {
-            entry.errorCallback((0, result_js_1.errorFromProto)(result["error"]));
-        }
-        else {
-            throw new errors_js_1.ProtoError("Received unexpected type of result");
+        } else if (result["type"] === "error") {
+            entry.errorCallback(
+                (0, result_js_1.errorFromProto)(result["error"])
+            );
+        } else {
+            throw new errors_js_1.ProtoError(
+                "Received unexpected type of result"
+            );
         }
     }
 }
@@ -218,7 +251,8 @@ async function errorFromResponse(resp) {
         }
     }
     if (resp.status === 404) {
-        message += ". It seems that the libsql server is outdated, please try updating the database.";
+        message +=
+            ". It seems that the libsql server is outdated, please try updating the database.";
     }
     return new errors_js_1.HttpServerError(message, resp.status);
 }
diff --git a/lib-esm/http/stream.js b/lib-esm/http/stream.js
index 186af16d9a6088b05f4bc2ac33ae9844e1a2ff69..25b243d375e70733bdc588587a42863eb34d7573 100644
--- a/lib-esm/http/stream.js
+++ b/lib-esm/http/stream.js
@@ -1,5 +1,10 @@
 import { fetch, Request, Headers } from "@libsql/isomorphic-fetch";
-import { ClientError, HttpServerError, ProtoError, ClosedError } from "../errors.js";
+import {
+    ClientError,
+    HttpServerError,
+    ProtoError,
+    ClosedError,
+} from "../errors.js";
 import { IdAlloc } from "../id_alloc.js";
 import { queueMicrotask } from "../ponyfill.js";
 import { errorFromProto } from "../result.js";
@@ -41,7 +46,10 @@ export class HttpStream extends Stream {
             "type": "store_sql",
             "sql_id": sqlId,
             "sql": sql,
-        }).then(() => undefined, (error) => this.#setClosed(error));
+        }).then(
+            () => undefined,
+            (error) => this.#setClosed(error)
+        );
         return new Sql(this, sqlState);
     }
     /** @private */
@@ -53,7 +61,10 @@ export class HttpStream extends Stream {
         this.#sendStreamRequest({
             "type": "close_sql",
             "sql_id": sqlState.sqlId,
-        }).then(() => this.#sqlIdAlloc.free(sqlState.sqlId), (error) => this.#setClosed(error));
+        }).then(
+            () => this.#sqlIdAlloc.free(sqlState.sqlId),
+            (error) => this.#setClosed(error)
+        );
     }
     /** @private */
     _execute(stmt) {
@@ -111,18 +122,24 @@ export class HttpStream extends Stream {
         }
         this.#closed = error;
         this.#client._streamClosed(this);
-        if (this.#baton !== null || this.#pipeline.length !== 0 || this.#pipelineInProgress) {
+        if (
+            this.#baton !== null ||
+            this.#pipeline.length !== 0 ||
+            this.#pipelineInProgress
+        ) {
             this.#pipeline.push({
                 request: { "type": "close" },
-                responseCallback() { },
-                errorCallback() { },
+                responseCallback() {},
+                errorCallback() {},
             });
             this.#flushPipeline();
         }
     }
     #sendStreamRequest(request) {
         if (this.#closed !== undefined) {
-            return Promise.reject(new ClosedError("Stream is closed", this.#closed));
+            return Promise.reject(
+                new ClosedError("Stream is closed", this.#closed)
+            );
         }
         return new Promise((responseCallback, errorCallback) => {
             this.#pipeline.push({ request, responseCallback, errorCallback });
@@ -138,27 +155,31 @@ export class HttpStream extends Stream {
         const promise = fetch(request);
         this.#pipelineInProgress = true;
         this.#pipeline.length = 0;
-        promise.then((resp) => {
-            if (!resp.ok) {
-                return errorFromResponse(resp).then((error) => {
-                    throw error;
-                });
-            }
-            return resp.json();
-        }).then((respJson) => {
-            const respBody = respJson;
-            this.#baton = respBody["baton"] ?? null;
-            this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
-            handlePipelineResponse(pipeline, respBody);
-        }).catch((error) => {
-            this.#setClosed(error);
-            for (const entry of pipeline) {
-                entry.errorCallback(error);
-            }
-        }).finally(() => {
-            this.#pipelineInProgress = false;
-            this.#flushPipeline();
-        });
+        promise
+            .then((resp) => {
+                if (!resp.ok) {
+                    return errorFromResponse(resp).then((error) => {
+                        throw error;
+                    });
+                }
+                return resp.json();
+            })
+            .then((respJson) => {
+                const respBody = respJson;
+                this.#baton = respBody["baton"] ?? null;
+                this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
+                handlePipelineResponse(pipeline, respBody);
+            })
+            .catch((error) => {
+                this.#setClosed(error);
+                for (const entry of pipeline) {
+                    entry.errorCallback(error);
+                }
+            })
+            .finally(() => {
+                this.#pipelineInProgress = false;
+                this.#flushPipeline();
+            });
     }
     #createPipelineRequest(pipeline) {
         const url = new URL("v2/pipeline", this.#baseUrl);
@@ -170,16 +191,25 @@ export class HttpStream extends Stream {
         if (this.#jwt !== null) {
             headers.set("authorization", `Bearer ${this.#jwt}`);
         }
+
+        console.log("[PATCHED @libsql/client ESM] executing SQL statements", {
+            "requests": pipeline.map((entry) => entry.request),
+            "url": url.toString(),
+        });
         return new Request(url, {
             method: "POST",
             headers,
             body: JSON.stringify(requestBody),
+            // do not cache in next.js
+            cache: "no-store",
         });
     }
 }
 function handlePipelineResponse(pipeline, respBody) {
     if (respBody["results"].length !== pipeline.length) {
-        throw new ProtoError("Server returned unexpected number of pipeline results");
+        throw new ProtoError(
+            "Server returned unexpected number of pipeline results"
+        );
     }
     for (let i = 0; i < pipeline.length; ++i) {
         const result = respBody["results"][i];
@@ -189,11 +219,9 @@ function handlePipelineResponse(pipeline, respBody) {
                 throw new ProtoError("Received unexpected type of response");
             }
             entry.responseCallback(result["response"]);
-        }
-        else if (result["type"] === "error") {
+        } else if (result["type"] === "error") {
             entry.errorCallback(errorFromProto(result["error"]));
-        }
-        else {
+        } else {
             throw new ProtoError("Received unexpected type of result");
         }
     }
@@ -214,7 +242,8 @@ async function errorFromResponse(resp) {
         }
     }
     if (resp.status === 404) {
-        message += ". It seems that the libsql server is outdated, please try updating the database.";
+        message +=
+            ". It seems that the libsql server is outdated, please try updating the database.";
     }
     return new HttpServerError(message, resp.status);
 }